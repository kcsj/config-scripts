sort {
    length enum: a, b, c, d, e, f.
    height enum: A, B, C, D, E, F.

    state {}.
}

function {
    path: height, length -> state {partial bijective}.

    start_state: state. {hidden} % start state ...
    end_state: state. {hidden} % end state ...
}

clause {
    start_state = MIN AND end_state = MAX. % strict ordering of states ...
    
    path(A, d) = start_state. % initial state ...
    path(D, d) = end_state. % goal state ...

    % move the robot ...
    path(x, y) = s AND path(w, z) = s+1 AND s < end_state -> DIF(x, w) + DIF(y, z) = 1.

    % ... cannot move where there are blocks ...
    NOT(path(A, f) = s). % blocks in the A row ...
    NOT(path(B, a) = s) AND NOT(path(B, c) = s). % blocks in the B row ...
    NOT(path(C, d) = s). % blocks in the C row ...
    NOT(path(D, b) = s) AND NOT(path(D, c) = s) AND NOT(path(D, e) = s). % blocks in the D row ...
    NOT(path(E, b) = s) AND NOT(path(E, e) = s). % blocks in the E row ...

    % the difference between the robot's location and the goal is not greater than the number of steps to get there ...
    path(x, y) = s -> NOT(DIF(x, D) + DIF(y, d) > DIF(s, end_state)).

}

end


% sort {
%      length enum: a, b, c, d, e, f.
%      height enum: A, B, C, D, E, F.

%      state {}.
% }

% function {
%      path: height, length -> state {partial bijective}.

%      start_state: state. {hidden}
%      end_state: state. {hidden}
% }


% clause {
%      start_state = MIN AND end_state = MAX. % strict ordering of states ...

%      path(A, d) = start_state. % initial state ...
%      path(D, d) = end_state. % goal state ...

%      % move the robot ...
%      path(x, y) = s AND path(w, z) = s+1 AND s < end_state -> DIF(x, w) + DIF(y, z) = 1.

%      % ... cannot move where there are blocks ...
%      NOT(path(A, f) = s). % blocks in the A row ...
%      NOT(path(B, a) = s) AND NOT(path(B, c) = s). % blocks in the B row ...
%      NOT(path(C, d) = s). % blocks in the C row ...
%      NOT(path(D, b) = s) AND NOT(path(D, c) = s) AND NOT(path(D, e) = s). % blocks in the D row ...
%      NOT(path(E, b) = s) AND NOT(path(E, e) = s). % blocks in the E row ...

%      % the difference between the robot's location and the goal is not greater than the number of steps to get there ...
%      path(x, y) = s -> NOT(DIF(x, D) + DIF(y, d) > DIF(s, end_state)).
% }
