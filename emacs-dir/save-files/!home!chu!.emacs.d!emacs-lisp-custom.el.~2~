;; =================================
;; custom emacs lisp code
;; Matthew Ball (copyleft 2008-2011)
;; =================================

;; ==============
;;; ansi terminal
;; ==============
(defun symbol-value-in-buffer (sym buf)
  "Return the value of 'sym' in 'buf'."
  (save-excursion
    (with-current-buffer buf
      (symbol-value sym))))

(defun start-term (&rest junk)
 "Start an ansi shell in the directory of current buffer."
 (interactive)
 (ansi-term "/bin/bash")
 (term-line-mode))

(defun switch-term (&rest junk)
  "Switch to an active shell (if one exists) or create a new shell (if none exists)."
  (interactive)
  (let ((found nil))
    (loop for b in (buffer-list)
	  if (eq (symbol-value-in-buffer 'major-mode b) 'term-mode)
	  do (switch-to-buffer b) (setq found t))
    (when (not found) (start-term))))

(defun kill-term (&rest junk)
  "Close an ansi shell session and kill the remaining buffer."
  (interactive)
  (when (equal major-mode (or 'term-mode 'eshell-mode))
      (progn
	(term-kill-subjob)
	(kill-buffer))))

;; =============
;;; custom LaTeX
;; =============
(define-skeleton bold ;; insert a bold text clause in a LaTeX document
  "Insert a bold clause in a LaTeX document."
  "String: "
  "\\textbf{" str | "insert text" "}")

(define-skeleton footnote ;; insert a footnote in a LaTeX document
  "Insert a footnote in a LaTeX document."
  "String: "
  "\\footnote{" str | "insert text" "}")

(define-skeleton tele-type ;; insert a tele-type text clause in a LaTeX document
  "Insert a tele-type text clause in a LaTeX document."
  "String: "
  "\\texttt{" str | "insert text" "}")

(define-skeleton emph ;; insert an emphasis text clause in a LaTeX document
  "Inserts an emphasis clause in a LaTeX document."
  "String: "
  "\\emph{" str | "insert text" "}")

(define-skeleton small-capitals ;; inserts a small capitals text clause in a LaTeX document
  "Inserts a small capital text clause in a LaTeX document."
  "String: "
  "\\textsc{" str | "insert text" "}")

;; ===========
;;; word count
;; ===========
(defun word-count (&optional b e)
  (interactive "r")
  (shell-command-on-region b e "wc -w"))


;; =======================
;;; org-remember templates
;; =======================
(setq remember-annotation-functions '(org-remember-annotation)
      remember-handler-functions '(org-remember-handler)
      org-remember-templates
      '(("Home" ?h "\n* TODO %^{Title} :HOME:\n + ADDED: %U\n + SCHEDULE: %^T%?\n" "home.org" "Home") ;; add a TODO for a task at home
	("Course" ?C "\n* %^{Course Code} :UNIVERSITY:\n + TITLE: %^{Course Title}\n + ADDED: %U%?\n" "school.org" "University") ;; add a new entry for a COURSE at university
	("Assignment" ?A "\n* TODO %^{Title} :ASSIGNMENT:\n + ADDED: %U\n + DEADLINE: %^T%?\n" "school.org" "%^{Course Code}") ;; add a TODO for a COURSE at university
	("Projects" ?p "\n* TODO %^{Title} :PROJECT:\n + ADDED: %U\n + SCHEDULE: %^T%?\n" "projects.org" "Projects") ;; add a TODO for a project task
	("General" ?g "\n* TODO %^{Title} :GENERAL:\n + ADDED: %U\n + SCHEDULE: %^T%?\n" "notes.org" "General") ;; add a TODO for a general task
	("Website" ?w "\n* %^{Title} :WEBSITE:\n + ADDED: %U\n + LINK: [[%^{Address}][%^{Name}]]\n%?\n" "notes.org" "Notes") ;; add an interesting web site
	("Notes" ?n "\n* %^{Title} :NOTES:\n + ADDED: %U\n + %^{Text}\n%?" "notes.org" "Notes"))) ;; add an interesting note

(add-hook 'remember-mode-hook 'org-remember-apply-template)

;; =================
;;; org-mode journal
;; =================
(defvar org-journal-file "~/Documents/Organisation/journal.org" "Path to org-mode journal file.")

(defvar org-journal-date-format "%Y-%m-%d" "Date format string for journal headings.")

(defun org-journal-entry ()
  "Create a new diary entry for today or append to an existing one."
  (interactive)
  (switch-to-buffer (find-file org-journal-file))
  (widen)
  (let ((today (format-time-string org-journal-date-format)))
    (beginning-of-buffer)
    (unless (org-goto-local-search-headings today nil t)
      ((lambda ()
         (org-insert-heading)
         (insert today)
         (insert "\n\n  \n"))))
    (beginning-of-buffer)
    (org-show-entry)
    (org-narrow-to-subtree)
    (end-of-buffer)
    (backward-char 2)
    (unless (= (current-column) 2)
      (insert "\n\n  "))))

;; =============
;;; abbreviation
;; =============
(setq abbrev-file-name "~/.emacs.d/abbrev_defs.el") ;; set abbreviation file
(abbrev-mode t) ;; enable abbreviations
(setq default-abbrev-mode t ;; turn on abbrev-mode
      save-abbrevs 'ask ;; ask to save abbreviations
      dabbrev-case-replace nil) ;; preserve case when expanding

(read-abbrev-file abbrev-file-name t)
(add-hook 'kill-emacs-hook 'write-abbrev-file) ;; update abbreviations when exiting emacs

;; =========================
;;; code folding (hide/show)
;; =========================
(hs-minor-mode 1)

(setq hs-hide-comments nil ;; hide the comments too when you do a 'hs-hide-all'
      hs-isearch-open 'code) ;; set whether isearch opens folded comments, code, or both

(defun toggle-selective-display (column)
  (interactive "P")
  (set-selective-display
   (or column
       (unless selective-display
	 (1+ (current-column))))))

(defun toggle-hiding (column)
  (interactive "P")
  (if hs-minor-mode
      (if (condition-case nil
	      (hs-toggle-hiding)
	    (error t))
	  (hs-show-all))
    (toggle-selective-display column)))

;; ======
;;; dired
;; ======
(defun dired-launch-command ()
  (interactive)
  (dired-do-shell-command
   (case system-type
     (gnu/linux "gnome-open")) ;; works for gnome (ubuntu), not for other systems
   nil
   (dired-get-marked-files t current-prefix-arg)))

(setq dired-load-hook (lambda () (define-key dired-mode-map (kbd "l") 'dired-launch-command))) ;; launch custom applications with dired

;; ============
;;; try-require
;; ============
(defvar missing-packages-list nil
  "List of packages that 'try-require' can't find.")

(defun try-require (feature) ;; attempt to load a feature/library, failing silently
  "Attempt to load a library or module. Return true if the library given as argument is successfully loaded.
If not, instead of an error, just add the package to a list of missing packages."
  (condition-case err
      (progn ;; protected form
        (message "Checking for library `%s'..." feature)
        (if (stringp feature)
            (load-library feature)
          (require feature))
        (message "Checking for library `%s'... Found" feature))
    (file-error  ;; condition
     (progn ;; error handler
       (message "Checking for library `%s'... Missing" feature)
       (add-to-list 'missing-packages-list feature 'append))
     nil)))

;; ==============
;;; auto-complete
;; ==============
(define-globalized-minor-mode real-global-auto-complete-mode ;; dirty fix for having AC everywhere
  auto-complete-mode (lambda () (if (not (minibufferp (current-buffer)))
			       (auto-complete-mode 1))))
(real-global-auto-complete-mode t)

