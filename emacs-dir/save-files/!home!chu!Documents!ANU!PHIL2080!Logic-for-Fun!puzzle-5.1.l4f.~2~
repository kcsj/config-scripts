sort {
     length enum: a, b, c, d, e, f.
     height enum: A, B, C, D, E, F.

     % position cardinality = 36. % 36 possible positions ...
     % position cardinality = 2. % two different types of positions (blocks, and the robot)
     position cardinality = 1.

     state {}.
}

function {
     place: state, length, height -> position {}. % movement ...
     place_block: length, height -> bool {hidden}. % placement of blocks ...

     robot: position. {hidden} % robot ...
     % block: position. {hidden} % blocks ...

     start_state: state. {hidden} % start state ...
     end_state: state. {hidden} % end state ...
}

clause {
     % see: equity and diversity (3.7; john's solution), for an idea of how to encode the initial 36 states of the board
     start_state = MIN AND end_state = MAX. % strict ordering of states ...

     place(start_state, d, A) = robot. % start position ...
     place(end_state, d, D) = robot. % end position ....

     % move the robot ...
     place(s+1, x, y) = robot AND (NOT(x = z OR y = w)) -> (place(s, z, y) = robot OR place(s, x, w) = robot) AND (DIF(x, z) < 2) AND (DIF(y, w) < 2).

     % positions of blocks ...
     place_block(f, A). % north-east corner is a block ...
     place_block(a, B).
     place_block(c, B).
     place_block(d, C).
     place_block(b, D).
     place_block(c, D).
     place_block(e, D).
     place_block(b, E).
     place_block(e, E).

     % ... cannot move where there are blocks ...
     place_block(z, y) -> NOT(place(s, z, y) = robot).


}

end


% #sorts#
% length enum: a, b, c, d, e, f.
% height enum: A, B, C, D, E, F.

% state {}.


% #functions#
% path: height, length -> state {partial bijective}.

% start_state: state. {hidden}
% end_state: state. {hidden}


% #clauses#
% start_state = MIN AND end_state = MAX. % strict ordering of states ...

% path(A, d) = start_state. % initial state ...
% path(D, d) = end_state. % goal state ...

% % move the robot ...
% path(x, y) = s AND path(w, z) = s+1 AND s < end_state -> DIF(x, w) + DIF(y, z) = 1.

% % ... cannot move where there are blocks ...
% NOT(path(A, f) = s). % blocks in the A row ...
% NOT(path(B, a) = s) AND NOT(path(B, c) = s). % blocks in the B row ...
% NOT(path(C, d) = s). % blocks in the C row ...
% NOT(path(D, b) = s) AND NOT(path(D, c) = s) AND NOT(path(D, e) = s). % blocks in the D row ...
% NOT(path(E, b) = s) AND NOT(path(E, e) = s). % blocks in the E row ...

% % the difference between the robot's location and the goal is not greater than the number of steps to get there ...
% path(x, y) = s -> NOT(DIF(x, D) + DIF(y, d) > DIF(s, end_state)).
